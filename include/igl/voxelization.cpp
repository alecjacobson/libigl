#include "voxelization.h"
#include <igl/mat_min.h>
#include <igl/mat_max.h>
#include <igl/read_triangle_mesh.h>
#include <igl/winding_number.h>
 
template <typename DerivedV, typename DerivedF, typename DerivedMC>
IGL_INLINE void igl::voxelization(
	const Eigen::MatrixBase<DerivedV> &V,
	const Eigen::MatrixBase<DerivedF> &F,
	const int maxn,
	int &X,
	int &Y,
	int &Z,
	Eigen::PlainObjectBase<DerivedMC> &min_cord,
	double &resolution,
	std::vector<int> &voxel) {

	const auto & max =
		[](double a, double b, double c) {
		double ret = a;
		if (b > ret) ret = b;
		if (c > ret) ret = c;
		return ret;
	};

	Eigen::RowVectorXd max_cord, temp;
	igl::mat_min(V, 1, min_cord, temp);
	igl::mat_max(V, 1, max_cord, temp);
	min_cord -= Eigen::RowVector3d(1, 1, 1);
	max_cord += Eigen::RowVector3d(1, 1, 1);
	double mx = max(max_cord(0) - min_cord(0), max_cord(1) - min_cord(1), max_cord(2) - min_cord(2));
	resolution = mx / (maxn - 1);
	X = floor((max_cord(0) - min_cord(0)) / resolution) + 1;
	Y = floor((max_cord(1) - min_cord(1)) / resolution) + 1;
	Z = floor((max_cord(2) - min_cord(2)) / resolution) + 1;
	voxel.resize(X*Y*Z, -1);

	const auto & check =
		[](const Eigen::RowVector3i now, const int X, const int Y, const int Z)
		->bool
	{
		if (now(0) < 0 || now(0) == X || now(1) < 0 || now(1) == Y || now(2) < 0 || now(2) == Z) return false;
		else return true;
	};

	Eigen::MatrixXi trans(6, 3), trans1(8, 3);
	trans << -1, 0, 0,
		1, 0, 0,
		0, -1, 0,
		0, 1, 0,
		0, 0, -1,
		0, 0, 1;
	trans1 << 0, 0, 0,
		0, 0, 1,
		0, 1, 0,
		0, 1, 1,
		1, 0, 0,
		1, 0, 1,
		1, 1, 0,
		1, 1, 1;

	std::list<Eigen::RowVector3i> lst;
	double w;
	Eigen::RowVector3i now = Eigen::RowVector3i(0, 0, 0), now1;
	Eigen::MatrixXi O1(V.rows() * 8, 3);
	int o = 0;
	for (int i = 0; i < V.rows(); i++) {
		for (int j = 0; j < 3; j++) {
			now(j) = floor((V(i, j) - min_cord(j)) / resolution);
		}
		for (int j = 0; j < 8; j++) {
			now += trans1.row(j);
			if (check(now, X, Y, Z) && voxel[now(0)*Y*Z + now(1)*Z + now(2)] == -1) {
				cnt++;
				O1.row(o) = now;
				voxel[now(0)*Y*Z + now(1)*Z + now(2)] = 2;
				o++;
			}
			now -= trans1.row(j);
		}
	}
	Eigen::MatrixXd O(o, 3);
	for (int i = 0; i < o; i++) {
		O.row(i) = min_cord + resolution * Eigen::RowVector3d(O1(i, 0), O1(i, 1), O1(i, 2));
	}
	Eigen::VectorXd W;
	igl::winding_number(V, F, O, W);
	int _o = 0;
	for (int i = 0; i < o; i++) {
		now = O1.row(i);
		if (W(i) > 0.5) {
			voxel[now(0)*Y*Z + now(1)*Z + now(2)] = 1;
		}
		else {
			voxel[now(0)*Y*Z + now(1)*Z + now(2)] = 0;
		}
		lst.push_back(now);
		_o++;
	}
	bool flag;
	std::list<Eigen::RowVector3i> _lst, n1;
	o = _o;
	while (o > 0) {
		_o = 0;
		for (int i = 0; i < o; i++) {
			now = lst.front();
			lst.pop_front();
			flag = false;
			now1 = now;
			for (int j = 0; j < 6; j++) {
				now = now + trans.row(j);
				if (check(now, X, Y, Z) && voxel[now(0)*Y*Z + now(1)*Z + now(2)] == -1) {
					_lst.push_back(now);
					n1.push_back(now1);
					voxel[now(0)*Y*Z + now(1)*Z + now(2)] = 2;
					_o++;
				}
				now = now - trans.row(j);
			}
		}
		Eigen::MatrixXd O(_o, 3);
		int i = 0;
		for (Eigen::RowVector3i vec : _lst) {
			O.row(i) = min_cord + resolution * Eigen::RowVector3d(vec(0), vec(1), vec(2));
			i++;
		}
		igl::winding_number(V, F, O, W);
		o = 0;
		Eigen::RowVector3i _now;
		for (int i = 0; i < _o; i++) {
			now = _lst.front();
			_lst.pop_front();
			now1 = n1.front();
			n1.pop_front();
			if (W(i) > 0.5) {
				voxel[now(0)*Y*Z + now(1)*Z + now(2)] = 1;
			}
			else {
				voxel[now(0)*Y*Z + now(1)*Z + now(2)] = 0;
			}
			flag = false;
			for (int j = 0; j < 6; j++) {
				_now = now1 + trans.row(j);
				if (check(_now, X, Y, Z) && (voxel[_now(0)*Y*Z + _now(1)*Z + _now(2)] == 1 || voxel[_now(0)*Y*Z + _now(1)*Z + _now(2)] == 0) &&
					voxel[now1(0)*Y*Z + now1(1)*Z + now1(2)] != voxel[_now(0)*Y*Z + _now(1)*Z + _now(2)]) {
					flag = true;
				}
			}
			if (flag) {
				o++;
				lst.push_back(now);
			}
		}
	}

	double s;
	for (int i = 0; i < X; i++)
		for (int j = 0; j < Y; j++) {
			s = 0;
			for (int k = 0; k < Z; k++) {
				if (voxel[i*Y*Z + j * Z + k] == -1) voxel[i*Y*Z + j * Z + k] = s;
				else s = voxel[i*Y*Z + j * Z + k];
			}
		}
}

#ifdef IGL_STATIC_LIBRARY
// Explicit template instantiation
// generated by autoexplicit.sh
#endif
